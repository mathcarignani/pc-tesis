
\newcommand{\coderBase}{\text{Base}}
\newcommand{\coderPCA}{\text{PCA}}
\newcommand{\coderAPCA}{\text{APCA}}
\newcommand{\coderCA}{\text{CA}}
\newcommand{\coderPWLH}{\text{PWLH}}
\newcommand{\coderPWLHInt}{\text{PWLHInt}}
\newcommand{\coderFR}{\text{FR}}
\newcommand{\coderSF}{\text{SF}}
\newcommand{\coderGAMPS}{\text{GAMPS}}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% CODER AND DECODER COMMANDS %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand{\minn}{\textit{m}}
\newcommand{\maxx}{\textit{M}}
\newcommand{\error}{\textit{err}}
\newcommand{\file}{\textit{in}}
\newcommand{\window}{\textit{win}}
\newcommand{\arrayy}{\textit{array}}
\newcommand{\windowVal}{\textit{win\_val}}
\newcommand{\windowSize}{$\textnormal{|}\window\textnormal{|}$}
\newcommand{\windowSizeT}{|\window|}

\newcommand{\encodedColumn}{\textit{encoded\_column}}
\newcommand{\entry}{\textit{y}}
\newcommand{\binFile}{binary file}
\newcommand{\variant}{\textit{v}}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% COMMON CODER COMMANDS %%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand{\cInputFile}{\file: CSV data file to be encoded}
\newcommand{\cInputColSize}{\colSize: number of entries in the column}
\newcommand{\cOutputFileA}{\out: \binFile \ with the encoding of \file}

\newcommand{\forEachEntryCoder}{\textnormal{entry} \entry \textnormal{ in} \column}
\newcommand{\createWindowOne}{Create an empty window, \window}
\newcommand{\createWindowTwo}{Set \window\ to an empty window}

\newcommand{\windowNotFullOne}{$\windowSize\ < \win$}
\newcommand{\windowFull}{$\windowSize \eqqq \win$}

\newcommand{\ifNoDataCoder}[1]{${#1} \eqqq \noData$\xspace}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% DECODER COMMANDS %%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\newcommand{\doutputfile}{\out: decoded column of CSV data file}

\newcommand{\cInputVariant}{\variant: variant (\maskalgo\ or \NOmaskalgo)}
\newcommand{\cInputThreshold}{\maxerror: maximum error threshold}
\newcommand{\cInputWindow}{\win: window size}
\newcommand{\cInputThresholdOpt}{\cInputThreshold} %\ // ignored by algorithm Base}
\newcommand{\cInputWindowOpt}{\cInputWindow} % \ // ignored by algorithms Base and SF}

\newcommand{\maskModeNoS}{$\variant \eqqq \maskalgo$}
\newcommand{\maskMode}{\maskModeNoS\ }

\newcommand{\whileColumnLeftToDecode}{$\notCond\ \file.\textnormal{column\_decoded?}$}
\newcommand{\whileColumnNotDecoded}{$n < \colSize$}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newcommand{\commonSpecific}[2]{{#1} {#2} using $\BeCe$ bits}
\newcommand{\encodeSpecific}[1]{\commonSpecific{Encode}{{#1}}}
\newcommand{\decodeSpecific}[1]{\commonSpecific{Decode}{{#1}}}

\newcommand{\codeFloat}[1]{Encode {#1} as a float, using 32 bits}
\newcommand{\decodeFloat}[1]{Decode {#1} as a float, using 32 bits}
\newcommand{\decodeWindowwSize}{Decode $\sizee$ using $\logWinSize$ bits}

%% BASE - CODER
\newcommand{\columnInput}{\column: column of the CSV data file to be encoded}

%% PCA - CODER
\newcommand{\cInputWindowPCA}{\win: fixed window size}
\newcommand{\calculateMinMax}{Let \minn\ and \maxx\ be the minimum and maximum sample values in \window}
\newcommand{\codeMidrange}{\codeInt(\midrange, \colTotBits)}
\newcommand{\eachValueInWindow}{\textnormal{sample in} \window\commaa\ \valuev,}
\newcommand{\eachEntryInWindow}{\textnormal{entry in} \window\commaa\ \entry,}
\newcommand{\codeBit}[1]{Output bit {#1} to \out}
%% PCA - DECODER
\newcommand{\nEqZero}{$n = 0$}
\newcommand{\calculateSize}{$\sizee = \min\{\win, \colSize - n\}$}
\newcommand{\decodeValuePCA}{\decodeSpecific{\midrange}}
\newcommand{\addNToSize}{$n \mathrel{+}= \sizee$}
\newcommand{\bit}{\textit{bit}}
\newcommand{\decodeBit}{Decode \bit\ from \file}

%% APCA - CODER
\newcommand{\cInputWindowAPCA}{\win: maximum window size}
\newcommand{\codeWindowValue}{\codeInt(\windowCodeValue, \colTotBits)}
\newcommand{\calculateMMaux}[2]{Let \minn\ and \maxx\ be the minimum and maximum sample values in #1, #2}
\newcommand{\calculateMinMaxAPCA}{\calculateMMaux{the extended window $[\window, y]$}{resp.}}

% TODO: borrar
\newcommand{\NOTvalidThreThree}{$M - m > 2\maxerror$}
\newcommand{\encodeWindowAPCA}{EncodeWindow(\window, \out, \win) // routine shown in Figure~\ref{apcaWindowM}}
\newcommand{\AddEntry}{Append \entry\ to \window}
%% APCA - WIN
\newcommand{\windowInput}{\window: window to encode}
\newcommand{\encodeWindowSizee}{Encode $|\window|$ using $\logWinSize$ bits}
\newcommand{\encodeWindowSizeeOne}{Encode 1 using $\logWinSize$ bits}

%% PWLH - CODER
\newcommand{\extendedWin}{extended window $[\window,\incomingNS]$}
\newcommand{\firstIteratPWHL}{\textnormal{\entry\ is not the first entry in \column}}
\newcommand{\EncodeWindowCA}{EncodeWindow}
\newcommand{\hull}{\textit{H}}
\newcommand{\encodeWindowPWLH}{\EncodeWindowCA(\window, \out, \win, \tscol) // routine shown in Figure~\ref{pwlhWindowM}}
\newcommand{\encodeLastWindowPWLH}{\EncodeLastWindowPWLH(\window, \out, \win, \tscol) // routine shown in Figure~\ref{pwlhLastWindowM}}
\newcommand{\tentry}{$t_\entry$}
\newcommand{\obtainTS}{Obtain timestamp for \entry, \tentry, from \tscol}
\newcommand{\letPointCoor}[3]{Let {#1}\ be the point with coordinates ({#2}, {#3})}
\newcommand{\letPoint}{\letPointCoor{\point}{\tentry}{\entry}}
\newcommand{\winNoEmpty}{\window \textnormal{ is not empty}}
\newcommand{\appendIncoming}{Append \point to \window}

%% CA - CODER
\newcommand{\windowEmptyCA}{\window\textnormal{ is empty (i.e. \archived was defined in the previous iteration)}}
\newcommand{\firstIteratCA}{\textnormal{\entry\ is the first entry in \column}}
\newcommand{\letPointCA}{Let \incoming\ be the point with coordinates (\tentry, \entry)}

\newcommand{\pointInput}{\valuev: value to encode}
\newcommand{\pointInputCA}{\archived: archived point to encode}

\newcommand{\encodeWinStaCACommon}[1]{\CAWinStartP(\archivedNS, \out) // #1 in Figure~\ref{caWinStart}}
\newcommand{\encodeWinStaCA}{\encodeWinStaCACommon{routine}}
\newcommand{\encodeWinEndCA}{\CAWinEndP(\window, \out, \win) // routine shown in Figure~\ref{caWinEnd}}

\newcommand{\addSnapshot}{append \snapshot to \window}
\newcommand{\AddSnapshot}{Append \snapshot to \window}
\newcommand{\xx}{\textit{x}}
\newcommand{\yy}{\textit{y}}

\newcommand{\letSminSmax}{Let \smin\ and \smax\ be the rays with initial point \archived, that pass through points $(\snapshot.\xx, \snapshot.\yy-\maxerror)$ and $(\snapshot.\xx, \snapshot.\yy+\maxerror)$, respectively}
\newcommand{\letSminSmaxOld}{Let \smino\ and \smaxo\ be rays equal to \smin\ and \smax, respectively}
\newcommand{\letSminSmaxUpdate}{Let $\smin=\max\{\smino, \smin\}$ and $\smax=\min\{\smaxo, \smax\}$}


\newcommand{\slope}{\textnormal{slope}}
\newcommand{\validCondCA}{$\slope(\smin)\leq \slope(\EseE) \leq\slope(\smax)$}
\newcommand{\letArchived}{Make $\archived = \incoming$}
\newcommand{\letSnapshot}{Make $\snapshot = \incoming$}


%% SF CODER
\newcommand{\addIncoming}{append \incoming to \window}
\newcommand{\AddIncoming}{Append \incoming to \window}
\newcommand{\lineSeg}{\textit{s}}


%% DECO - LINEAR
\newcommand{\tss}{\textit{t}}
\newcommand{\sv}{\textit{s}}
\newcommand{\tsO}{$\tss_o$}
\newcommand{\tsN}{$\tss_f$}
\newcommand{\tsI}{$\tss_i$}
\newcommand{\sI}{$\sv_i$}

\newcommand{\inputTSCol}{\tscol: timestamp column}
\newcommand{\inputTSO}{\tsO: timestamp of the first endpoint of the segment}
\newcommand{\inputTSN}{\tsN: timestamp of the last endpoint of the segment}
\newcommand{\inputSO}{\sO: sample value of the first endpoint of the segment}
\newcommand{\inputSN}{\sN: sample value of the last endpoint of the segment}

\newcommand{\decodedSamples}{\textit{decoded\_samples}}
\newcommand{\decodedSamplesTwo}{\textit{samples}}
\newcommand{\outputDecoded}{\decodedSamples: list with the sample values decoded from the segment}
\newcommand{\forEachTS}{\textnormal{timestamp \tsI\ in \tscol,}}
\newcommand{\ifDecoLinear}{\tsO \ $\leq$ \tsI \ $\leq$ \tsN}
\newcommand{\AddEntryLinear}{Append \sI\ to \decodedSamples}
