
\clearpage

\section{Algorithm GAMPS}
\label{algo:gamps}


\vspace{-10pt}
Algorithm \textit{Grouping and AMPlitude Scaling (GAMPS)} \cite{coder:gamps} is a correlation model algorithm that supports lossless and near-lossless compression. It has a window size parameter ($w$) that establishes the maximum block size in which the data are separately encoded. For GAMPS we define both variants, \maskalgo\ and \NOmaskalgo.


Algorithm GAMPS follows the general schema presented in Figure~\ref{pseudoCodeCommon}, with a specific coding routine, for variant \maskalgo, shown in Figure~\ref{pseudoCoderGAMPS}. Notice that the first input consists of all the columns in the csv data file, while in the routines for the constant and linear model algorithms, presented in previous sections, it is a single column. This is due to the fact that constant and linear model algorithms only exploit the temporal correlation in the data, thus they encode each data column independently. However, correlation model algorithms, such as GAMPS, also exploit the spatial correlation, thus they encode the data columns simultaneously. Another difference with the previously presented algorithms, is that GAMPS is an offline encoder, so the whole dataset is available when the coding routine begins. 


Before encoding the data columns, algorithm GAMPS groups them into disjoint subsets of spatially correlated columns. In each subset, a single \textit{base column} is defined, while the rest of its columns are referred to as \textit{ratio columns}. The base column is encoded with algorithm APCA, and the ratio columns are first transformed, dividing each sample by the base column sample corresponding to the same timestamp, then encoded, which is also done with algorithm APCA. The original ratio signals may be rough, but, since base and ratio signals in the same subset are spatially correlated, \textit{the transformed ratio signals are expected to be slowly varying}. As we recall from Section~\ref{algo:apca}, algorithm APCA achieves better compression performances on slowly varying signals rather than rough signals. Therefore, the key idea behind algorithm GAMPS is that, under certain circumstances, it may be more convenient to exploit the spatial correlation between the signals, and encode, for each subset, a single rough base signal and a handful of slowly varying transformed signals, rather than independently encode each of the original rough signals.


\vspace{-5pt}
\input{chapters/Algorithms/pseudo/12-GAMPS/GAMPS-M-C}


\clearpage


The initial step in the coding routine, which gives the first part of its name to the algorithm, consists of grouping the data columns into disjoint subsets of spatially correlated columns (\Line~1). A facility location problem, whose goal is to find a grouping that reduces the number of bits required for encoding the columns, is resolved \cite{coder:gamps}. Its inputs are the set of columns, \columns, and the maximum error threshold, \maxerror, and the output is the grouping and two maximum error threshold parameters, \epsilonB\ and \epsilonR, used for encoding the base and ratio columns, respectively. To solve the facility location problem we reuse the source code from the framework cited in \cite{AnEva2013}. We point out that we narrow the universe of solutions by only allowing columns corresponding to signals of the same data type to be grouped together. We find out that this not only reduces the size of the facility location problem, which is computationally expensive to solve, but in our case it also lead to better compression results. 


The next step in the coding routine consists of encoding the number of subsets (\Line 2). Afterwards, the routine iterates through each subset of columns (\Lines 4-11), and, in each iteration, all the data columns in the subset are encoded. In \Line 6, the index of the base column, and the number of ratio columns and their respective indexes are encoded. This information is used by the decoding routine to recreate each subset. In \Line 7, the base column is encoded by invoking the coding routine for algorithm APCA, shown in Figure~\ref{pseudoCoderAPCAM}, with an error threshold equal to \epsilonB. Finally, there is a loop in \Lines 8-11, in which each of the ratio columns is transformed, as explained above, then encoded by invoking the APCA coding routine\footnote{Since a transformed ratio column may include non-integer values, in this case the auxiliary routine EncodeWindow for algorithm APCA, shown in Figure~\ref{apcaWindowM}, encodes the \midrange\ as a float, i.e. using 32 bits.}, with an error threshold equal to \epsilonR.


% The transformation applied to a ratio column, in \Line 9, dividing each sample by the base column sample corresponding to the same timestamp. The original ratio signals may be rough, but, since there is a high degree of spatial correlation among base and ratio signals in a group, the transformed ratio signals are expected to be slowly varying. As we recall from Section~\ref{algo:apca}, algorithm APCA achieves better compression performances on slowly varying signals rather than rough signals. Therefore, the key idea behind algorithm GAMPS is that, under certain circumstances, it may be more convenient to exploit the spatial correlation between the signals, and encode a single rough base signal and a handful of slowly varying transformed signals, rather than independently encode each of the original rough signals.


The decoding routine is symmetric to the coding routine. To recreate each subset, the information encoded in \Lines 2 and 6 of the coding routine is decoded. For decoding the data columns in each subset, first, the base column is decoded by invoking the decoding routine for algorithm APCA. Then, each of the transformed ratio columns is decoded, also by invoking the APCA decoding routine, and the transformation applied in \Line 9 is reverted, by multiplying the decoded base column by the decoded transformed ratio column.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\clearpage


\subsection{Example}
\label{algo:gamps:example}


Next we present an example of the encoding of three signals with 12 samples each, illustrated in Figure~\ref{example:gamps:1}. \exampleRecallIrrelevant{APCA}. Therefore, they are also irrelevant for algorithm GAMPS. For this example we let the error threshold parameter ($\maxerror$) be equal to 0, and the maximum window size ($\win$) equal to 256.


\exampleStep{gamps}{1}{\label{example:gamps:1}}{Algorithm GAMPS example. Step 0.}


There is a high degree of spatial correlation among the three signals, with the sample values matching for 10 of the 12 timestamps. Therefore, in \Line 1, a single subset including the three columns with the samples of each signal is created. The first column is defined as the base column, making the remaining two, ratio columns. Since \maxerror\ is equal to 0, both \epsilonB\ and \epsilonR, must also be 0. In \Line 2, the number of subsets (i.e. 1) is encoded using $\gampsSizeAux{|\columns|}=\gampsSizeAux{3}=2$ bits. Since there is a single subset, there is a single iteration. In \Line 6, the information used by the decoding routine to recreate the subset is encoded, using $\gampsSizeAux{|\columns|}=2$ bits for encoding each of the following values: the index of the base column (i.e. 0), the number of ratio columns (i.e. 2), and the index of each ratio column (i.e. 1 and 2). 


Next, in \Line 7, the base column is encoded by calling the coding routine for algorithm APCA. Since \epsilonB\ is equal to 0, the encoded samples match the original samples. The loop in \Lines 8 through 11 repeats for each of the two ratio columns. In both cases, the ratio column is first transformed (\Line 9), then encoded by calling the APCA coding routine (\Line 10). Since parameter \epsilonR\ is equal to 0, the encoded samples match the transformed samples, which are equal to $[1, 1, 1, 1, 1, 4/3, 4/3, 1, 1, 1, 1, 1]$ and $[1, 1, 1, 1, 1, 2/3, 2/3, 1, 1, 1, 1, 1]$, respectively, for each transformed ratio column. In Figure~\ref{example:gamps:2}, the encoded samples of the three signals are shown. 


We recall that the coding routine for algorithm APCA always uses the same amount of bits for encoding a window. If the three signals were independently encoded with APCA, the first one would require encoding 5 windows, and the second and third signals would require encoding 7 windows each. However, in this example, only 3 windows are required for encoding each of the transformed ratio signals with algorithm APCA. This is expected because, since there is a high degree of spatial correlation among the signals, the transformed ratio signals are slowly varying, compared to the original ratio signals, which are more rough.


\clearpage


\exampleStep{gamps}{2}{\label{example:gamps:2}}{Algorithm GAMPS example. Step 1.}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\subsection{Non-Masking (\NOmaskalgo)\ variant}
\label{algo:gamps:nmvariant}


The coding and decoding routines for variant \NOmaskalgo\ of algorithm GAMPS are quite similar to their variant \maskalgo\ counterparts, the difference being that the former routines are able to handle both sample values and gaps. The coding routine for variant \maskalgo\ of algorithm GAMPS invokes the coding routine for variant \maskalgo\ of algorithm APCA (\Lines 7 and 10 in Figure~\ref{pseudoCoderGAMPS}), which can only handle sample values, since the position of the gaps is already encoded (recall \Line 7 in Figure~\ref{pseudoCodeCommon}). However, the coding routine for variant \NOmaskalgo\ of algorithm GAMPS must instead invoke the coding routine for variant \NOmaskalgo\ of algorithm APCA, presented in Subsection~\ref{algo:apca:nmvariant}, which is able to handle both sample values and gaps.

