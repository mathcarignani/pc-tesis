

\newcommand{\InputdisPoints}{\disPoints: array including the \window\ indexes of the displaced points}
\newcommand{\InputWindow}{\window: window}
\newcommand{\InputFirstIndex}{$\firstIndex$, $\lastIndex$: \window\ indexes of the candidate line segment's endpoints}

\newcommand{\DPconditionTwoOne}{$\firstIndex + 1 < \lastIndex$}
\newcommand{\DPconditionTwoTwo}{$\notCond\ \validSegment$}




\beginAlgorithm
\onlyInput{\InputWindow\\\cInputThreshold\\\InputdisPoints\\\InputFirstIndex}
If they are not included, add $\firstIndex$ and $\lastIndex$ to \disPoints, in ascending order\\
\If{\DPconditionTwoOne}{
    \returnn
}
Let the following points be defined: \pointo$=\window[\firstIndex]$ and \pointf$=\window[\lastIndex]$\\
Let \segment\ be the line segment whose endpoints are \pointo\ and \pointf\\
Let \validSegment\ be true iff for every point \pointi\ in \window, the vertical distance between \segment\ and \pointi\ is less than or equal to \maxerror\\
\If{\DPconditionTwoTwo}{
    Let \half\ =\ $\floor{(\firstIndex +\lastIndex) / 2}$\\
    \getDisplacedPoints{\firstIndex}{\half}\\
    \getDisplacedPoints{\half}{\lastIndex}\\
}
\EndPseudo{Auxiliary routine \getDisplacedPointsMethod\ for algorithm \coderFR.}{\label{pseudoCoderFRM2}}

