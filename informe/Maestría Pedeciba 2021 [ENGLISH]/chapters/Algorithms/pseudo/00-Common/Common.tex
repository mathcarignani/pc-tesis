
\newcommand{\coderBase}{\text{Base}}
\newcommand{\coderPCA}{\text{PCA}}
\newcommand{\coderAPCA}{\text{APCA}}
\newcommand{\coderCA}{\text{CA}}
\newcommand{\coderPWLH}{\text{PWLH}}
\newcommand{\coderPWLHInt}{\text{PWLHInt}}
\newcommand{\coderFR}{\text{FR}}
\newcommand{\coderSF}{\text{SF}}
\newcommand{\coderGAMPS}{\text{GAMPS}}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% CODER AND DECODER COMMANDS %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand{\minn}{\textit{min}}
\newcommand{\maxx}{\textit{max}}
\newcommand{\minntwo}{\textit{m}}
\newcommand{\maxxtwo}{\textit{M}}
\newcommand{\error}{\textit{err}}
\newcommand{\file}{\textit{in}}
\newcommand{\out}{\textit{out}}
\newcommand{\window}{\textit{win}}
\newcommand{\arrayy}{\textit{array}}
\newcommand{\windowVal}{\textit{win\_val}}
\newcommand{\windowSize}{$\textnormal{|}\window\textnormal{|}$}
\newcommand{\windowSizeT}{|\window|}

\newcommand{\encodedColumn}{\textit{encoded\_column}}
\newcommand{\entry}{\textit{entry}}
\newcommand{\binFile}{binary file}
\newcommand{\variant}{\textit{v}}

\newcommand{\windowUnion}{$\window\cup\entry$}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% CODER COMMANDS %%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newcommand{\cInputFile}{\file: csv data file to be encoded}
\newcommand{\cInputColSize}{\colSize: number of entries in the column}

\newcommand{\cOutputFileA}{\out: \binFile \ with the encoding of \file}
\newcommand{\cOutputFile}[1]{\out: \binFile\ encoded with algorithm #1}


\newcommand{\forEachEntryCoder}{\textnormal{entry in} \column\commaa\ \entry\commaa}
\newcommand{\createWindowOne}{Create an empty window, \window}
\newcommand{\createWindowTwo}{Set \window\ to an empty window}

\newcommand{\windowNotFullOne}{$\windowSize\ < \win$}
\newcommand{\windowFull}{$\windowSize \eqqq \win$}
\newcommand{\validThreTwo}{$|\maxx - \minn| \leq 2\maxerror$}

\newcommand{\ifNoDataCoder}[1]{${#1} \eqqq \noData$\xspace}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% DECODER COMMANDS %%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newcommand{\dinputCol}[1]{\column: column encoded with algorithm #1}
\newcommand{\dinputfileA}{\file: coded \binFile}
\newcommand{\dinputfile}[1]{\file: \binFile\ coded with algorithm #1}
\newcommand{\doutputfile}{\out: decoded csv data file}

\newcommand{\cInputVariant}{\variant: variant (\maskalgo\ or \NOmaskalgo)}
\newcommand{\cInputThreshold}{\maxerror: maximum error threshold}
\newcommand{\cInputWindow}{\win: window size}
\newcommand{\cInputThresholdOpt}{\cInputThreshold} %\ // ignored by algorithm Base}
\newcommand{\cInputWindowOpt}{\cInputWindow} % \ // ignored by algorithms Base and SF}

\newcommand{\tsColumn}{\text{ts\_column}}
\newcommand{\maskModeNoS}{$\variant \eqqq \maskalgo$}
\newcommand{\maskMode}{\maskModeNoS\ }

\newcommand{\whileColumnLeftToDecode}{$\notCond\ \file.\textnormal{column\_decoded?}$}
\newcommand{\whileColumnNotDecoded}{$n < \colSize$}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newcommand{\commonSpecific}[2]{{#1} {#2} using a (column-specific) fixed number of bits}
\newcommand{\encodeSpecific}[1]{\commonSpecific{Encode}{{#1}}}
\newcommand{\decodeSpecific}[1]{\commonSpecific{Decode}{{#1}}}

\newcommand{\codeFloat}[1]{Encode {#1} as a float, using 32 bits}
\newcommand{\decodeFloat}[1]{Decode {#1} as a float, using 32 bits}

% TODO: borrar
\newcommand{\calculateMinMax}{Let \minn\ and \maxx\ be the minimum and maximum sample values in \window}
\newcommand{\recalculateMinMax}{recalculate \minn\ and \maxx}

\newcommand{\encodeWindowSize}{Encode $\windowSize$ using $\logWinSize$ bits}
\newcommand{\decodeWindowwSize}{Decode $\sizee$ using $\logWinSize$ bits}


%% BASE - CODER
\newcommand{\columnInput}{\column: column of the csv data file to be encoded}

%% PCA - CODER
\newcommand{\cInputWindowPCA}{\win: fixed window size}
% TODO: remove
\newcommand{\calculateMidrange}{$\midrange = (\windowMin + \windowMax)/2$}
\newcommand{\calculateMidrangeTwo}{$\midrange = (\minn + \maxx)/2$}
\newcommand{\calculateMidrangeThree}{$\midrange = (\minntwo + \maxxtwo)/2$}
\newcommand{\codeMidrange}{\codeInt(\midrange, \colTotBits)}
\newcommand{\eachValueInWindow}{\textnormal{sample in} \window\commaa\ \valuev,}
\newcommand{\eachEntryInWindow}{\textnormal{entry in} \window\commaa\ \entry,}
\newcommand{\codeBit}[1]{Output bit {#1} to \out}
%% PCA - DECODER
\newcommand{\nEqZero}{$n = 0$}
\newcommand{\calculateSize}{$\sizee = \min\{\win, \colSize - n\}$}
\newcommand{\decodeValuePCA}{\decodeSpecific{\midrange}}
\newcommand{\addNToSize}{$n \mathrel{+}= \sizee$}
\newcommand{\bit}{\textit{bit}}
\newcommand{\decodeBit}{Decode \bit\ from \file}

%% APCA - CODER
\newcommand{\cInputWindowAPCA}{\win: maximum window size}
\newcommand{\codeWindowValue}{\codeInt(\windowCodeValue, \colTotBits)}
\newcommand{\calculateMMaux}[2]{Let \minntwo\ and \maxxtwo\ be the minimum and maximum sample values in #1, #2}
\newcommand{\calculateMinMaxAPCA}{\calculateMMaux{\windowUnion}{resp.}}
\newcommand{\calculateMinMaxAPCAWindow}{\calculateMMaux{\window}{respectively}}

% TODO: borrar
\newcommand{\updateMinMaxx}{Let $m  = \min \{\minn, \entry\}$ and $M  = \max \{\maxx, \entry\}$}
\newcommand{\NOTvalidThreThree}{$(M - m) > 2\maxerror$}
\newcommand{\encodeWindowAPCA}{EncodeWindow(\window, \out, \win) // routine shown in Figure~\ref{apcaWindowM}}
\newcommand{\AddEntry}{Add \entry\ to \window}
%% APCA - WIN
\newcommand{\windowInput}{\window: window to encode}
\newcommand{\encodeWindowSizee}{Encode $|\window|$ using $\logWinSize$ bits}
\newcommand{\encodeWindowSizeeOne}{Encode 1 using $\logWinSize$ bits}

%% PWLH - CODER
\newcommand{\firstIteratPWHL}{\textnormal{\entry\ is not the first entry in \column}}

%% CA - CODER
\newcommand{\windowEmpty}{\window\textnormal{ is empty}}
\newcommand{\firstIteratCA}{\textnormal{\entry\ is the first entry in \column}}
\newcommand{\letPointCA}{Let \incoming\ be the point with coordinates (\tentry, \entry)}

\newcommand{\pointP}{\textit{P}}
\newcommand{\pointInput}{\valuev: value to encode}

\newcommand{\encodeWinStaCACommon}[1]{\CAWinStartP(\entry, \out, \win) // #1 in Figure~\ref{caWinStart}}
\newcommand{\encodeWinStaCA}{\encodeWinStaCACommon{routine}}
\newcommand{\encodeWinEndCA}{\CAWinEndP(\window, \out, \win) // routine shown in Figure~\ref{caWinEnd}}

\newcommand{\addSnapshot}{add \entry\ to \window}
\newcommand{\xx}{\textit{x}}
\newcommand{\yy}{\textit{y}}

\newcommand{\letSminSmax}{Let \smin\ and \smax\ be the rays with initial point \archived, that pass through points $(\snapshot.\xx, \snapshot.\yy-\maxerror)$ and $(\snapshot.\xx, \snapshot.\yy+\maxerror)$, respectively}
\newcommand{\letSminSmaxOld}{Let \smino\ and \smaxo\ be rays equal to \smin\ and \smax, respectively}
\newcommand{\letSminSmaxUpdate}{Let $\smin=\max\{\smino, \smin\}$ and $\smax=\min\{\smaxo, \smax\}$}


\newcommand{\slope}{\textnormal{slope}}
\newcommand{\validCondCA}{$\slope(\smin)\leq \slope(\EseE) \leq\slope(\smax)$}
\newcommand{\letArchived}{Make $\archived = \incoming$}
\newcommand{\letSnapshot}{Make $\snapshot = \incoming$}


%% DECO - LINEAR
\newcommand{\tss}{\textit{t}}
\newcommand{\sv}{\textit{s}}
\newcommand{\tscol}{\textit{t\_col}}
\newcommand{\tsO}{$\tss_o$}
\newcommand{\tsN}{$\tss_f$}
\newcommand{\tsI}{$\tss_i$}
\newcommand{\sO}{$\sv_o$}
\newcommand{\sN}{$\sv_f$}
\newcommand{\sI}{$\sv_i$}

\newcommand{\inputTSCol}{\tscol: timestamp column}
\newcommand{\inputTSO}{\tsO: timestamp of the first endpoint of the segment}
\newcommand{\inputTSN}{\tsN: timestamp of the last endpoint of the segment}
\newcommand{\inputSO}{\sO: sample value of the first endpoint of the segment}
\newcommand{\inputSN}{\sN: sample value of the last endpoint of the segment}

\newcommand{\decodedSamples}{\textit{decoded\_samples}}
\newcommand{\decodedSamplesTwo}{\textit{samples}}
\newcommand{\outputDecoded}{\decodedSamples: list with the sample values decoded from the segment}
\newcommand{\forEachTS}{\textnormal{timestamp in \tscol,} \tsI,}
\newcommand{\ifDecoLinear}{\tsO \ $\leq$ \tsI \ $\leq$ \tsN}
\newcommand{\AddEntryLinear}{Add \sI\ to \decodedSamples}
