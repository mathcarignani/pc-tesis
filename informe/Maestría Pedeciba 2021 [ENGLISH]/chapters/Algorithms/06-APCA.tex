
\clearpage

\section{Algorithm APCA}
\label{algo:apca}


Algorithm \textit{Adaptive Piecewise Constant Approximation (APCA)} \cite{coder:apca} is a constant model algorithm that supports lossless and near-lossless compression. As its name suggests, it operates similarly to algorithm PCA, the difference being that in APCA the size of the blocks in which the data are separately encoded is not fixed, but variable. In this case, the window size parameter ($\win$) establishes a maximum block size for the algorithm. APCA supports both variants, \maskalgo\ and \NOmaskalgo.


In Figure~\ref{pseudoCoderAPCAM} we show the coding routine for variant \maskalgo, in which all the column entries are integer values (the gaps are encoded separately). It consists of a loop that iterates over all column entries. The algorithm maintains a window of consecutive samples, $\window$, which is initially empty (\Line 1). In each iteration, the addition of an entry to the window is considered (\Lines 3-8). If the new entry makes the window violate the error threshold constraint (i.e. the absolute difference between its maximum and minimum values is greater than $2\maxerror$), or the window size greater than $\win$, then the window is encoded, and emptied (\Lines 5-6). In any case, the current entry is added to $\window$ (\Line 8), and is eventually encoded. In particular, if the loop ends and $\window$ is not empty, it is encoded in \Line 11. 


\input{chapters/Algorithms/pseudo/06-APCA/APCA-M-C}


\vspace{+2pt}
The auxiliary routine used for encoding a window (in \Lines 5 and 11), EncodeWindow, is shown in Figure~\ref{apcaWindowM}. Observe that every window is encoded with the same number of bits, i.e. $\logWinSize +\totbit$, where $\logWinSize$ bits are used for encoding its size, and $\totbit$ bits, \wheretotbit, are used for encoding its mid-range.
\vspace{+3pt}


\input{chapters/Algorithms/pseudo/06-APCA/APCA-Win-M-C}


\clearpage


The decoding routine for variant \maskalgo\ is shown in Figure~\ref{pseudoDecoderAPCAM}. It consists of a loop that keeps running until every entry in the column has been decoded, which occurs when the condition in \Line 2 becomes false. The decoding loop is fairly simple. First, both the window size, \sizee, and its mid-range value are decoded (\Lines 3-4). Then, the mid-range value is written \sizee\ times to the decoded csv data file (\Line~5).


\input{chapters/Algorithms/pseudo/06-APCA/APCA-M-D}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\vspace{-10pt}
\subsection{Example}
\label{algo:apca:example}
\newcommand{\APCACodeOne}{4}
\newcommand{\APCACodeTwo}{11}
\newcommand{\exampleIntroFirst}[1]{Next we present an example of the encoding of the same 12 samples of previous examples, presented in Figure~\ref{example:pca:1}, and also shown in Figure~#1 below}


Next we present an example of the encoding of the same 12 samples of the previous example, presented in Figure~\ref{example:pca:1}, and also shown in Figure~\ref{example:apca:1} below. \exampleRecallIrrelevant{APCA}. For this example we let the error threshold parameter ($\maxerror$) be equal to 1, and the maximum window size ($\win$) equal to 256. 


The condition in \Line \APCACodeOne\ of the coding routine evaluates to false in the first eight iterations, so these samples, $[1, 1, 1, 1, 1, 2, 3, 3]$, are added to the first window. The sample processed in the 9th iteration is 4, whose addition to the window would violate the error threshold constraint, because we have $|4 - 1| > 2*1$. Therefore, the window is encoded, which requires $\logWinSize = \logWinSizeOpt{256}=8$ bits for encoding its size (i.e. 8), and \tobitexp\ for encoding its mid-range (i.e. 2), and the sample value 4 is added to a new empty window. This step is shown in Figure~\ref{example:apca:1}.


\exampleStep{apca}{1}{\label{example:apca:1}}{Algorithm APCA example. Step 1.}


For the second window, the condition in \Line \APCACodeOne\ evaluates to false in the 10th iteration. However, the error threshold constraint is violated in the 11th iteration, for the sample value 1. The second window, $[4, 2]$, is encoded with size 2 and mid-range 3, and the sample value 1 is added to a new empty window. This step is shown in Figure~\ref{example:apca:2}.


\exampleStep{apca}{2}{\label{example:apca:2}}{Algorithm APCA example. Step 2.}


For the third window, the condition in \Line \APCACodeOne\ evaluates to false in the 12th and last iteration. This window, which is equal to $[1, 1]$, is encoded in \Line \APCACodeTwo, after executing the last iteration. In this case, the window size is 2 and its mid-range is 1. This last step is shown in Figure~\ref{example:apca:3}.


\exampleStep{apca}{3}{\label{example:apca:3}}{Algorithm APCA example. Step 3.}


We point out that each of the three windows in this example are encoded using exactly the same amount of bits. However, the first window consists of eight samples, while the last two consist of only two samples. Therefore, the first window achieves a better compression ratio (more samples encoded per bit). This example illustrates why, similarly to PCA, algorithm APCA is expected to achieve better compression performances on slowly varying signals rather than rough signals.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\clearpage
\subsection{Non-Masking (\NOmaskalgo)\ Variant}
\label{algo:apca:nmvariant}


The coding and decoding routines for variant \NOmaskalgo\ of algorithm APCA are similar to their variant \maskalgo\ counterparts, the difference being that the former routines are able to handle both sample values and gaps. Recall that in the coding routine for variant \maskalgo, a window is encoded when adding a new entry makes it violate the error threshold constraint or the window size restriction (\Line 4 in Figure~\ref{pseudoCoderAPCAM}). In the coding routine for variant \NOmaskalgo, a window must also be encoded if the incoming entry is character \noData\ (gap in the data) and the other entries in the window are integers (sample values), or vice versa. A window that consists of gaps is encoded with the same number of bits as a window that consists of integers, i.e. $\logWinSize+\totbit$, where $\logWinSize$ bits are used for encoding its size, and $\totbit$ bits, \wheretotbit, are used for encoding the special integer \nodata.

