
\section{Algorithm FR}
\label{algo:fr}

Algorithm \textit{Fractal Resampling (FR)} \cite{coder:fr} is a linear model algorithm that supports lossless and near-lossless compression. Its computational complexity is fairly low, since it was designed by the European Space Association (ESA) to be run on spacecraft and planetary probes. It has a window size parameter ($w$) that establishes the maximum block size in which the data are separately encoded. For FR we define a single variant, \maskalgo.


Since FR is a linear model algorithm, from Section~\ref{algo:decolinear} we recall that its encoding process involves encoding a sequence of line segments. In particular, the data points in each window are modeled by one or more line segments that are selected using a simple recursive technique called mid-point displacement. In Figure~\ref{pseudoCoderFRM} we show the coding routine, in which all the column entries are integer values (the gaps are encoded separately). The points obtained from parsing the x-coordinates and y-coordinates from the timestamps and the data column, respectively, are added into consecutive non-overlapping windows of size $\win$ (\Line 1), and each of these windows is encoded independently (\Lines 3-14).


Since \win\ is always greater than 1, the condition in \Line 3 may only be satisfied in the last iteration. In the rest of the cases, an array, \disPoints, is created (\Line 9), and passed to the recursive auxiliary routine \getDisplacedPointsMethod\ (\Line 10), which fills it with the \window\ indexes of the displaced points. These points correspond to the endpoints of the one or more line segments that model all the points in the window. \disPoints\ always includes the first and last index of \window, since the first line segment must always begin in the first point of the window, and the last segment must always end in the last point of the window. In \Lines 11-15, every one of the endpoints is encoded, using $\logWinSize$ bits for encoding their \window\ index, and \tobitexp for encoding their y-coordinate.


\clearpage


\input{chapters/Algorithms/pseudo/11-FR/FR-M-C}


The recursive routine \getDisplacedPointsMethod\ is shown in Figure~\ref{pseudoCoderFRM2}. In each execution, a line segment, with endpoints given by \window\ indexes $\firstIndex$ and $\lastIndex$, is \textbf{considered/evaluated} as a candidate to model all the points in \window\ between those endpoints. In \Line 1, both indexes are added to the \disPoints\ array. The condition in \Line 2 is satisfied when there are no additional points between both endpoints, which is the base case of the recursive routine. Otherwise, the routine checks if the error threshold condition is violated by any of the points in the candidate segment (\Line 7), and if that is the case, there are two recursive calls to the routine (\Lines 10-11). Notice that the last endpoint of the candidate segment in the first call is equal to the first endpoint of the candidate segment in the second call, which is the point given by the \window\ index \half, defined in \Line 9.

\input{chapters/Algorithms/pseudo/11-FR/FR-M-C2}


The decoding routine is shown in Figure~\ref{pseudoDecoderFRM}. It consists of a loop that keeps running until every entry in the column has been decoded, which occurs when condition in \Line 2 becomes false. In each iteration of the loop, a window is decoded independently (\Lines 3-26). Since \win\ is always greater than 1, the condition in \Line 4 may only be satisfied in the last iteration. Notice that \Lines 4-8 are correlated with \Lines 3-7 in the coding routine. In the rest of the cases, the size of the encoded window is always greater than 2, so the data values are decoded by means of obtaining the endpoints of the one or more line segments that model the points in the window. The first endpoint of the first segment is decoded in \Lines 9-12, while the last endpoint of each segment, which becomes the first endpoint of each subsequent segment (\Line 24), is decoded in \Lines 14-17. Next, auxiliary routine \decodeSegment is called with their coordinates as inputs (\Line 18). This routine (recall Figure~\ref{pseudoDecoLinear}) returns a list consisting of the sample values that are decoded from the segment, which are then written in the decoded csv data file (\Lines 19-23). The condition in \Line 20 is meant to avoid writing the sample value associated to the last endpoint of a segment, for every segment that models the points in the window, minus the last one. Otherwise, those sample values would be written in the decoded data file twice, since the last endpoint of a segment coincides with the first endpoint of the subsequent segment.


\vspace{+10pt}
\input{chapters/Algorithms/pseudo/11-FR/FR-M-D}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\clearpage
\subsection{Example}
\label{algo:fr:example}


\exampleIntro{\ref{example:fr:1}}


Since there are only 12 samples to encode, a single window, $\window$, which includes 12 points, is created in \Line 1 of the coding routine. In this case, since $|\window|$ is greater than 1, the window is encoded in \Lines 8-14. 


In \Line 9, the auxiliary routine \getDisplacedPointsMethod\ is invoked with parameters $\window$, $\maxerror=1$, $\disPoints=[]$, $\firstIndex = 0$ and $\lastIndex = 11$. Figure~\ref{example:fr:1} shows the information after executing \Lines 1-7 in said routine. $\disPoints$ is equal to $[0, 11]$, and \segment\ is the line segment whose endpoints are the points in $\window$ with indexes $0$ and $11$, i.e. the first and last points in the window. Also, \validSegment\ is false, since there are three points in $\window$ with indexes between $0$ and $11$, for which the vertical distance to \segment\ is greater than~\maxerror. Since \validSegment\ is false, $\half=\floor{11/2}=5$ is obtained (\Line 9), and two recursive calls to the auxiliary routine \getDisplacedPointsMethod\ are made (\Lines 10-11).


% \vspace{-5pt}
\exampleStep{fr}{1}{\label{example:fr:1}}{Algorithm FR example. Step 1.}


The first recursive call has parameters $\disPoints=[0, 11]$, $\firstIndex = 0$ and $\lastIndex = 5$, and it adds a single index to $\disPoints$, making it equal to $[0, 5, 11]$. In this case, \segment\ is the line segment whose endpoints are the points in $\window$ with indexes $0$ and $5$, and the error threshold constraint is satisfied, since there are no points in $\window$ with indexes between $0$ and $5$, for which the vertical distance to \segment\ is greater than~\maxerror. This is shown in Figure~\ref{example:fr:2}. Therefore, in the execution of the first recursive call, there are no further calls made to the routine \getDisplacedPointsMethod.


\clearpage


% \vspace{-5pt}
\exampleStep{fr}{2}{\label{example:fr:2}}{Algorithm FR example. Step 2.}


However, this is not the case in the execution of the second recursive call, which has parameters $\disPoints=[0, 5, 11]$, $\firstIndex = 5$ and $\lastIndex = 11$. Here, Figure~\ref{example:fr:2} shows that the error threshold constraint is violated by three points in the window, which means that, once again, $\half=\floor{(5 + 11) / 2}=8$ is obtained, and two recursive calls to the routine \getDisplacedPointsMethod\ must be made. In both of these executions, the error threshold constraint is satisfied, so there are no further calls made to the recursive routine. 


After the original invocation of the routine \getDisplacedPointsMethod\ is completed (\Line 9 in the coding routine, shown in Figure~\ref{pseudoCoderFRM}), $\disPoints$ is equal to $[0, 5, 8, 11]$. This information is shown in Figure~\ref{example:fr:3}. Observe that all the points in $\window$ satisfy the error threshold constraint.


\exampleStep{fr}{3}{\label{example:fr:3}}{Algorithm FR example. Step 3.}


In this example, the data points in $\window$ are modeled by three line segments, whose respective endpoints are the four displaced points, which are encoded in \Lines 10-14 of the coding routine. Encoding an endpoint requires $\logWinSize = \logWinSizeOpt{256}=8$ bits for encoding its \window\ index, and \tobitexp for encoding its y-coordinate. The four encoded endpoints and the associated segments are shown in Figure~\ref{example:fr:4}. In this figure we also display the values of the decoded samples, which are the values that the decoding routine, shown in Figure~\ref{pseudoDecoderFRM}, writes to the decoded csv data file. 


\exampleStep{fr}{4}{\label{example:fr:4}}{Algorithm FR example. Step 4.}


\clearpage

