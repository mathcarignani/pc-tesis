

\newcommand{\InputdisPoints}{\disPoints: list including the indexes (relative to \window, in ascending order) of the respective displaced points}
\newcommand{\InputFirstIndex}{$\firstIndex$, $\lastIndex$: indexes (relative to \window) of the endpoints of the candidate line segment}

\newcommand{\DPconditionTwoOne}{$\firstIndex + 1 < \lastIndex$}
\newcommand{\DPconditionTwoTwo}{$\notCond\ \validSegment$}




\beginAlgorithm
\onlyInput{\windowInput\\\cInputThreshold\\\InputdisPoints\\\InputFirstIndex}
If they are not already included, add $\firstIndex$ and $\lastIndex$ to \disPoints, in ascending order\\
If $\firstIndex + 1 \geq \lastIndex$ then \returnn // base case\\ 
Let \pointo$=\window[\firstIndex]$, and let \pointf$=\window[\lastIndex]$\\
Let \segment\ be the line segment whose endpoints are \pointo\ and \pointf\\
Let \validSegment\ be true iff for every point \pointi\ in \window, the vertical distance between \segment\ and \pointi\ is less than or equal to \maxerror\\
\If{\DPconditionTwoTwo}{
    Let \half\ =\ $\floor{(\firstIndex +\lastIndex) / 2}$\\
    Recursively call \getDisplacedPoints{\firstIndex}{\half}\\
    Recursively call \getDisplacedPoints{\half}{\lastIndex}\\
}
\EndAuxVarM{\getDisplacedPointsMethod}{FR}{\label{pseudoCoderFRM2}}

