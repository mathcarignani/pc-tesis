



\newcommand{\winEntries}[1]{\window.\textnormal{entries}[{{#1}}]}
\newcommand{\winSetValue}[1]{\winEntries{{{#1}}}.\text{value}}
\newcommand{\forEachInRange}{\indexx \textnormal{ in} $[0..\winSize-1]$}
\newcommand{\segmentEquation}{\text{segment\_equation}}
\newcommand{\DPvalue}{\textnormal{value}}
\newcommand{\DPpoint}{\textit{point}}
\newcommand{\forEachDisplaced}{\textnormal{entry in} \disPoints\commaa\ \indexx\commaa}
\newcommand{\getDisplacedPoints}[2]{$\getDisplacedPointsMethod(\window, \tscol, \maxerror, \disPoints, {#1}, {#2})$}

\newcommand{\winEntriesNO}{\window.\textnormal{entries}}
\newcommand{\winEntriesValue}{\winSetValue{\indexx}}

\newcommand{\encodeIndex}{Encode \indexx\ using $\logWinSize$ bits}

\newcommand{\pointdp}{$P_{\indexx}$}


\beginAlgorithm
\onlyInput{\columnInput\\\cOutputFile{FR}\\\cInputThreshold\\\cInputWindowAPCA\\\inputTSCol}
\parseWindowsPCA\\
\ForEach{\forEachWindowPCA}{
    \If{$|\window| == 1$}{
        Let \valuev\ be the single entry in \window\\
        \encodeSpecific{$\valuev$}\\
        \returnn\\
    }
    Create an empty list, \disPoints\\
    \getDisplacedPoints{0}{\windowSizeT-1} // routine in Fig.~\ref{pseudoCoderFRM2} \\
    \ForEach{\forEachDisplaced}{
        \encodeIndex\\
        \encodeSpecific{\winIndex}\\
    }
}
\EndAlgorithmVariant{Coding}{\coderFR}{\maskalgo}{\label{pseudoCoderFRM}}

