
\section{Algorithm GAMPS}
\label{algo:gamps}
\newcommand{\apcaF}{$\textnormal{APCA}_\textnormal{F}$}


\vspace{-5pt}
Algorithm \textit{\GAMPSfull} \cite{coder:gamps} is a correlation model algorithm that supports lossless and near-lossless compression. \WindowParam \BothVariantsOne{GAMPS}.


Algorithm GAMPS follows the general scheme presented in Figure~\ref{pseudoCodeCommon}, with a specific coding routine, for variant \maskalgo, shown in Figure~\ref{pseudoCoderGAMPS}. Notice that the first input consists of all the columns in the CSV data file, in contrast to constant and linear model algorithms, presented in previous sections, which receive a single column. This is due to the fact that correlation model algorithms, such as GAMPS, also exploit the spatial correlation in the data, thus they jointly encode the data columns. 
% Another difference with the previously presented algorithms, is that GAMPS is an offline encoder, so the whole dataset is available when the coding routine begins. 


Before encoding the data columns, algorithm GAMPS groups them into disjoint subsets of spatially correlated columns. In each subset, a single \textit{base column} is defined, while the rest of its columns are referred to as \textit{ratio columns}. \Revisor{As we describe in the sequel, this grouping, the optimization of the grouping, and the choice of the base column for each subset, is done trough an auxiliary algorithm.} The base column is encoded using algorithm \apcaF, which is quite similar to algorithm APCA, presented in Chapter~\ref{algo:apca}, the only differences being that in the auxiliary routine EncodeWindow, shown in Figure~\ref{apcaWindowM}, in the \apcaF\ case, floor is not applied when calculating \midrange, and \midrange is encoded as a float (i.e. using 32 bits). The ratio columns are first transformed, dividing each sample by the base column sample corresponding to the same timestamp (to avoid division by zero the samples of the base column are offset), and then encoded, which is also done using \apcaF. The original ratio signals may be rough (i.e. with abrupt changes), but, since base and ratio signals in the same subset are spatially correlated, the transformed ratio signals are expected to be smooth (i.e. slowly varying). As we recall from Section~\ref{algo:apca}, algorithm APCA achieves better compression performances on smooth rather than rough signals, and this is also the case for algorithm \apcaF. Therefore, the key idea behind algorithm GAMPS is that, under certain circumstances, it may be more convenient to exploit the spatial correlation in the data, and encode, for each subset, a single rough base signal and a handful of smooth transformed signals, rather than independently encode each of the original rough signals.


\vspace{-5pt}
\input{chapters/3-Algorithms/pseudo/12-GAMPS/GAMPS-M-C}


The initial step in the coding routine, which gives the first part of its name to the algorithm, consists of grouping the data columns into disjoint subsets of spatially correlated columns (\Line~1). A \textit{facility location problem}, whose goal is to find a grouping that reduces the number of bits required for encoding the columns, \Revisor{is solved in \cite[\S4.2.1]{coder:gamps}}. Its inputs are the set of columns, \columns, and the maximum error threshold, \maxerror. The output is the grouping\Revisor{, including the base column for each group, and the two maximum error threshold parameters, \epsilonB\ and \epsilonR, used for encoding each base column and its ratio columns, respectively. In the case that no such grouping of spatially correlated columns is found, the trivial output consists of groups formed by a single (base) column, and \epsilonB = \maxerror.} We point out that we narrow the universe of solutions by only allowing columns corresponding to signals of the same data type to be grouped together. We find out that this not only reduces the size of the facility location problem, which is computationally expensive to solve, but in our case it also lead to better compression results. 


The next step in the coding routine consists of encoding the number of subsets (\Line 2). Afterwards, the routine iterates through each subset of columns (\Lines 4-11). In each iteration, all the data columns in the subset are encoded. In \Line 6, the index of the base column, and the number of ratio columns and their respective indexes are encoded. This information is used by the decoding routine to recreate each subset. In \Line 7, the base column is encoded by invoking the coding routine for algorithm \apcaF\ with an error threshold equal to \epsilonB. Finally, there is a loop in \Lines 8-11, in which each of the ratio columns is transformed, as explained above, and then encoded by invoking the \apcaF\ coding routine with an error threshold equal to \epsilonR. \Revisor{We point out that this loop is only executed if the output of the facility location problem solved in the initial step of the coding routine is non-trivial.}


The decoding routine is symmetric to the coding routine. To recreate each subset, the information encoded in \Lines 2 and 6 of the coding routine must be decoded. For decoding the data columns in each subset, first, the base column is decoded by invoking the decoding routine for algorithm \apcaF. Then, each of the transformed ratio columns is decoded, also by invoking the \apcaF\ decoding routine, and the transformation applied in \Line 9 is reverted, by multiplying the decoded base column by the decoded transformed ratio column.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\subsection{Example}
\label{algo:gamps:example}


Next we present an example of the encoding of three signals with 12 samples each, illustrated in Figure~\ref{example:gamps:1}. \exampleRecallIrrelevant{APCA}, and this is also the case for algorithm \apcaF. Therefore, they are also irrelevant for algorithm GAMPS. For this example we let the error threshold parameter ($\maxerror$) be equal to 0, and the maximum window size ($\win$) equal to 256. \Revisor{We point out that this is the only example where the coding is lossless. In this case we select $\maxerror = 0$ so that the facility location problem considered in \Line 1 has a straightforward solution, and we can focus on illustrating the most important parts of the algorithm.}


\vspace{+5pt}
\exampleStepCommon{gamps}{1}{\label{example:gamps:1}}{Example: Three signals consisting of 12 samples each.}


There is a high degree of spatial correlation between the three signals, with the sample values matching for 10 of the 12 timestamps. Thus, in \Line 1, a single subset including the three columns with the samples of each signal is obtained. The first column is defined as the base column, making the remaining two, ratio columns. Since \maxerror\ is equal to 0, both \epsilonB\ and \epsilonR\ must also be 0. In \Line 2, the number of subsets (i.e. 1) is encoded using $\gampsSizeAux{|\columns|}=\gampsSizeAux{3}=2$ bits. Since there is a single subset, there is a single iteration. In \Line 6, the information used by the decoding routine to recreate the subset is encoded, using $\gampsSizeAux{|\columns|}=2$ bits for encoding each of the following values: the index of the base column (i.e. 0), the number of ratio columns (i.e. 2), and the index of each ratio column (i.e. 1 and 2). Therefore, a total of 10 bits are required for encoding the grouping of the columns in this example.


Next, in \Line 7, the base column is encoded by calling the coding routine for algorithm \apcaF. Since \epsilonB\ is equal to 0, the encoded samples match the original samples (i.e. [1, 1, 2, 2, 3, 3, 3, 3, 4, 4, 3, 3]), and 5 windows are encoded. The loop in \Lines 8 through 11 repeats for each of the two ratio columns. In both cases, the ratio column is first transformed (\Line 9), and then encoded by calling the \apcaF\ coding routine (\Line 10). Since parameter \epsilonR\ is equal to 0, the encoded samples match the transformed samples, which are equal to $[1, 1, 1, 1, 1, 4/3, 4/3, 1, 1, 1, 1, 1]$ and $[1, 1, 1, 1, 1, 2/3, 2/3, 1, 1, 1, 1, 1]$, respectively, for each transformed ratio column, and 3 windows are encoded in each case. In Figure~\ref{example:gamps:2}, the encoded samples of the three signals are shown. 


\vspace{+5pt}
\exampleStepGAMPS{gamps}{2}{\label{example:gamps:2}}{1}


We recall that the coding routine for algorithm APCA always uses the same number of bits for encoding any window. Namely, $\logWinSize$ bits are used for encoding its size, and $\BeCe$ bits are used for encoding its mid-range. Instead, the coding routine for algorithm \apcaF\ encodes the mid-range as a float (i.e. using 32 bits), so every window is encoded using exactly $\logWinSize + 32$ bits. If the three original signals were independently encoded with \apcaF, encoding the first one would involve encoding 5 windows, while encoding the second and third signals would involve encoding 7 windows in each case. However, in this example, even though encoding the base signal also involves encoding 5 windows, encoding the transformed ratio signals involves encoding only 3 windows in each case. Therefore, grouping and encoding the transformed signals allows the algorithm to reduce the total number of encoded windows by 8 (from 19 to 11), which reduces the number of encoded bits by exactly $8*(\logWinSize + 32) - 10$ bits (the 10 bits that are subtracted are used to encode the grouping of the columns). This is expected because, since there is a high degree of spatial correlation between the signals, the transformed ratio signals are smooth, compared to the original ratio signals, which are rough.


% \clearpage


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\subsection{Non-Masking (\NOmaskalgo)\ variant}
\label{algo:gamps:nmvariant}


The coding and decoding routines for variant \NOmaskalgo\ of algorithm GAMPS are quite similar to their variant \maskalgo\ counterparts, the difference being that the former routines are able to handle both sample values and gaps. The coding routine for variant \maskalgo\ of algorithm GAMPS invokes the coding routine for variant \maskalgo\ of algorithm APCA (\Lines 7 and 10 in Figure~\ref{pseudoCoderGAMPS}), which can only handle sample values, since the position of the gaps is already encoded (recall \Line \gapLine\ in Figure~\ref{pseudoCodeCommon}). However, the coding routine for variant \NOmaskalgo\ of algorithm GAMPS must instead invoke the coding routine for variant \NOmaskalgo\ of algorithm APCA, presented in Subsection~\ref{algo:apca:nmvariant}, which is able to handle both sample values and gaps.

