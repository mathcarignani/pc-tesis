
\clearpage

\section{Algorithm GAMPS}
\label{algo:gamps}
\newcommand{\apcaF}{$\textnormal{APCA}_\textnormal{F}$}


\vspace{-5pt}
Algorithm \textit{\GAMPSfull} \cite{coder:gamps} is a correlation model algorithm that supports lossless and near-lossless compression. It has a window size parameter ($w$) that establishes the maximum block size in which the data are separately encoded. For GAMPS we define both variants, \maskalgo\ and \NOmaskalgo.


Algorithm GAMPS follows the general schema presented in Figure~\ref{pseudoCodeCommon}, with a specific coding routine, for variant \maskalgo, shown in Figure~\ref{pseudoCoderGAMPS}. Notice that the first input consists of all the columns in the CSV data file, in contrast to constant and linear model algorithms, presented in previous sections, which receive a single column. This is due to the fact that correlation model algorithms, such as GAMPS, also exploit the spatial correlation in the data, thus they jointly encode the data columns. 
% Another difference with the previously presented algorithms, is that GAMPS is an offline encoder, so the whole dataset is available when the coding routine begins. 


Before encoding the data columns, algorithm GAMPS groups them into disjoint subsets of spatially correlated columns. In each subset, a single \textit{base column} is defined, while the rest of its columns are referred to as \textit{ratio columns}. The base column is encoded using algorithm \apcaF, which is quite similar to algorithm APCA. presented in Chapter~\ref{algo:apca}, the only difference being that in the auxiliary routine EncodeWindow, shown in Figure~\ref{apcaWindowM}, in the \apcaF\ case the \midrange\ is encoded as a float (i.e. using 32 bits). The ratio columns are first transformed, dividing each sample by the base column sample corresponding to the same timestamp (to avoid division by zero base column's samples are offset), then encoded, which is also done using \apcaF. The original ratio signals may be rough, but, since base and ratio signals in the same subset are spatially correlated, the transformed ratio signals are expected to be slowly varying. As we recall from Section~\ref{algo:apca}, algorithm APCA achieves better compression performances on slowly varying signals rather than rough signals, and this is also the case for algorithm \apcaF. Therefore, the key idea behind algorithm GAMPS is that, under certain circumstances, it may be more convenient to exploit the spatial correlation between the signals, and encode, for each subset, a single rough base signal and a handful of slowly varying transformed signals, rather than independently encode each of the original rough signals.


\vspace{-5pt}
\input{chapters/3-Algorithms/pseudo/12-GAMPS/GAMPS-M-C}


\clearpage


The initial step in the coding routine, which gives the first part of its name to the algorithm, consists of grouping the data columns into disjoint subsets of spatially correlated columns (\Line~1). A \textit{facility location problem}, whose goal is to find a grouping that reduces the number of bits required for encoding the columns, is resolved \cite{coder:gamps}. Its inputs are the set of columns, \columns, and the maximum error threshold, \maxerror, and the output is the grouping and two maximum error threshold parameters, \epsilonB\ and \epsilonR, used for encoding the base and ratio columns, respectively. We point out that we narrow the universe of solutions by only allowing columns corresponding to signals of the same data type to be grouped together. We find out that this not only reduces the size of the facility location problem, which is computationally expensive to solve, but in our case it also lead to better compression results. 


The next step in the coding routine consists of encoding the number of subsets (\Line 2). Afterwards, the routine iterates through each subset of columns (\Lines 4-11), and, in each iteration, all the data columns in the subset are encoded. In \Line 6, the index of the base column, and the number of ratio columns and their respective indexes are encoded. This information is used by the decoding routine to recreate each subset. In \Line 7, the base column is encoded by invoking the coding routine for algorithm \apcaF\ with an error threshold equal to \epsilonB. Finally, there is a loop in \Lines 8-11, in which each of the ratio columns is transformed, as explained above, then encoded by invoking the \apcaF\ coding routine with an error threshold equal to \epsilonR.


% The transformation applied to a ratio column, in \Line 9, dividing each sample by the base column sample corresponding to the same timestamp. The original ratio signals may be rough, but, since there is a high degree of spatial correlation among base and ratio signals in a group, the transformed ratio signals are expected to be slowly varying. As we recall from Section~\ref{algo:apca}, algorithm APCA achieves better compression performances on slowly varying signals rather than rough signals. Therefore, the key idea behind algorithm GAMPS is that, under certain circumstances, it may be more convenient to exploit the spatial correlation between the signals, and encode a single rough base signal and a handful of slowly varying transformed signals, rather than independently encode each of the original rough signals.


The decoding routine is symmetric to the coding routine. To recreate each subset, the information encoded in \Lines 2 and 6 of the coding routine must be decoded. For decoding the data columns in each subset, first, the base column is decoded by invoking the decoding routine for algorithm \apcaF. Then, each of the transformed ratio columns is decoded, also by invoking the \apcaF\ decoding routine, and the transformation applied in \Line 9 is reverted, by multiplying the decoded base column by the decoded transformed ratio column.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\subsection{Example}
\label{algo:gamps:example}


Next we present an example of the encoding of three signals with 12 samples each, illustrated in Figure~\ref{example:gamps:1}. \exampleRecallIrrelevant{APCA}, and this is also the case for algorithm \apcaF. Therefore, they are also irrelevant for algorithm GAMPS. For this example we let the error threshold parameter ($\maxerror$) be equal to 0, and the maximum window size ($\win$) equal to 256.


\vspace{+5pt}
\exampleStepCommon{gamps}{1}{\label{example:gamps:1}}{Example: Three signals consisting of 12 samples each.}


\clearpage


There is a high degree of spatial correlation among the three signals, with the sample values matching for 10 of the 12 timestamps. Thus, in \Line 1, a single subset including the three columns with the samples of each signal is created. The first column is defined as the base column, making the remaining two, ratio columns. Since \maxerror\ is equal to 0, both \epsilonB\ and \epsilonR\ must also be 0. In \Line 2, the number of subsets (i.e. 1) is encoded using $\gampsSizeAux{|\columns|}=\gampsSizeAux{3}=2$ bits. Since there is a single subset, there is a single iteration. In \Line 6, the information used by the decoding routine to recreate the subset is encoded, using $\gampsSizeAux{|\columns|}=2$ bits for encoding each of the following values: the index of the base column (i.e. 0), the number of ratio columns (i.e. 2), and the index of each ratio column (i.e. 1 and 2). Therefore, a total of 10 bits are encoded up to this point.


Next, in \Line 7, the base column is encoded by calling the coding routine for algorithm \apcaF. Since \epsilonB\ is equal to 0, the encoded samples match the original samples (i.e. [1, 1, 2, 2, 3, 3, 3, 3, 4, 4, 3, 3]), and 5 windows are encoded. The loop in \Lines 8 through 11 repeats for each of the two ratio columns. In both cases, the ratio column is first transformed (\Line 9), then encoded by calling the \apcaF\ coding routine (\Line 10). Since parameter \epsilonR\ is equal to 0, the encoded samples match the transformed samples, which are equal to $[1, 1, 1, 1, 1, 4/3, 4/3, 1, 1, 1, 1, 1]$ and $[1, 1, 1, 1, 1, 2/3, 2/3, 1, 1, 1, 1, 1]$, respectively, for each transformed ratio column, and 3 windows are encoded in each case. In Figure~\ref{example:gamps:2}, the encoded samples of the three signals are shown. 


\vspace{+5pt}
\exampleStepGAMPS{gamps}{2}{\label{example:gamps:2}}{1}


We recall that the coding routine for algorithm APCA always uses the same number of bits for encoding any window. Namely, $\logWinSize$ bits are used for encoding its size, and a column-specific fixed number of bits is used for encoding its mid-range. Instead, the coding routine for algorithm \apcaF\ encodes the mid-range as a float (i.e. using 32 bits), so every window is encoded using exactly $\logWinSize + 32$ bits. If the three original signals were independently encoded with \apcaF, encoding the first one would involve encoding 5 windows, while encoding the second and third signals would involve encoding 7 windows in each case. However, in this example, encoding the base signal also involves encoding 5 windows, but encoding the transformed ratio signals involves encoding only 3 windows in each case. Therefore, grouping and encoding the transformed signals allows the algorithm to reduce the total number of encoded windows by 8 (from 19 to 11), which reduces the number of encoded bits by exactly $8*(\logWinSize + 32) - 10$ bits. This is expected because, since there is a high degree of spatial correlation among the signals, the transformed ratio signals are slowly varying, compared to the original ratio signals, which are more rough.


\clearpage


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\subsection{Non-Masking (\NOmaskalgo)\ variant}
\label{algo:gamps:nmvariant}


The coding and decoding routines for variant \NOmaskalgo\ of algorithm GAMPS are quite similar to their variant \maskalgo\ counterparts, the difference being that the former routines are able to handle both sample values and gaps. The coding routine for variant \maskalgo\ of algorithm GAMPS invokes the coding routine for variant \maskalgo\ of algorithm APCA (\Lines 7 and 10 in Figure~\ref{pseudoCoderGAMPS}), which can only handle sample values, since the position of the gaps is already encoded (recall \Line \gapLine\ in Figure~\ref{pseudoCodeCommon}). However, the coding routine for variant \NOmaskalgo\ of algorithm GAMPS must instead invoke the coding routine for variant \NOmaskalgo\ of algorithm APCA, presented in Subsection~\ref{algo:apca:nmvariant}, which is able to handle both sample values and gaps.

