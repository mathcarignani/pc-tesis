
\clearpage

\section{Algorithm CA}
\label{algo:ca}


Algorithm \textit{\CAfull} \cite{coder:ca} is a linear model algorithm that supports lossless and near-lossless compression. It has a window size parameter ($w$) that establishes a maximum block size for the algorithm. CA supports both variants, \maskalgo and \NOmaskalgo.


Since CA is a linear model algorithm, its encoding process involves the encoding of a sequence of line segments. In Figure~\ref{pseudoCoderCAM} we show the coding routine for variant \maskalgo, in which all the column entries are integer values (the gaps are encoded separately). It consists of a loop that iterates over all column entries, parsing them into an alternating sequence of a single sample followed by a window of variable size (up to a maximum size $\win$), such that all the points representing entries in the same window lie within vertical distance \maxerror from the segment whose endpoints correspond to the single sample and the last entry of the window. The routine operates by successively encoding a single sample (using an auxiliary routine \CAWinStart, shown in Figure~\ref{caWinStart}), then growing a window of subsequent samples, adding one entry at a time until it is complete, and finally encoding the size and the last sample of the window (using an auxiliary routine \CAWinEnd, shown in Figure~\ref{caWinEnd}).


\input{chapters/3-Algorithms/pseudo/09-CA/CA-M-C}


\clearpage


\input{chapters/3-Algorithms/pseudo/09-CA/CA-WinStart-C}


\input{chapters/3-Algorithms/pseudo/09-CA/CA-WinEnd-C}


The algorithm determines when to stop growing the window, i.e., when the current window $\window$ is complete, based upon three points: \textit{archived (\archived)} is the point corresponding to a single sample that precedes a window; \textit{snapshot (\snapshot)} is the point corresponding to the entry most recently added to $\window$; \textit{incoming (\incoming)} is the point associated to the column entry for the current iteration. The algorithm maintains a cone, determined by two rays departing from \archived, \smin and \smax, such that the current column entry is added to $\window$ as long as the point \incoming lies within the cone. This cone, in turn, is defined so that if the current column entry is indeed added to $\window$, all the points representing the entries in $\window$ are at a vertical distance at most \maxerror from the segment $(\archived, \incoming)$.


In figures \ref{example:caIntro1} and \ref{example:caIntro2} we present an example that illustrates the key steps of the coding algorithm. In Figure~\ref{example:caIntro1} the three points, \archived, \snapshot, and \incoming, as well as the two rays departing from \archived, \smin and \smax, are shown. \archived is defined in the first iteration (\Line 6), while \snapshot and the two rays are defined in the second iteration (\Lines 8-9). In the third iteration, \incoming lies within the cone determined by the two rays, so the condition in \Line 12 evaluates to false (we assume that $|\window|<\win$), i.e. $\window$ is not complete, and \Lines 17-20 are executed: \snapshot is made equal to \incoming, the current column entry is added to $\window$ (\Line 17), and \smin and \smax are updated (\Lines 18-20). The updated information is shown in Figure~\ref{example:caIntro2}. 


\vspace{+5pt}
\exampleCA


\clearpage


In the successive iterations, the cone keeps reducing its slope, until eventually either point \incoming lies outside of the cone, or $\window$ reaches its maximum size. When this occurs, $\window$ is complete, and the condition in \Line 12 becomes true, so the size and last sample of $\window$ are encoded (\Line 13), $\window$ is emptied (\Line 14), and the process starts again, by defining point \archived and encoding the column entry for the current iteration (\Line 15).


The decoding routine for variant \maskalgo is shown in Figure~\ref{pseudoDecoderCA}. It consists of a loop that keeps running until every entry in the column has been decoded, which occurs when condition in \Line~2 becomes false. In each iteration, two values, \sizee and \valuev, are decoded from the binary file. \valuev corresponds to the y-coordinate of a point, whose x-coordinate is obtained from the timestamp column (\Line 5). If \sizee is equal to 1, \valuev is the result of an encoding produced by routine \CAWinStart (recall Figure~\ref{caWinStart}), so it corresponds to the y-coordinate of an archived point (\archived). In this case, point \archived is saved and \valuev is written to the decoded CSV data file (\Lines 7-8). On the other hand, if \sizee is greater than one, \valuev comes from an encoding produced by routine \CAWinEnd (recall Figure~\ref{caWinEnd}), so it corresponds to the y-coordinate of the last snapshot point (\snapshot) whose column entry was added to the window. In this case, the points representing the entries in the window are modeled by a line segment, whose endpoints are \archived and \snapshot, so the auxiliary routine \decodeSegment is called with their respective coordinates as inputs (\Line 11). Routine \decodeSegment (recall Figure~\ref{pseudoDecoLinear}) returns a list consisting of the sample values that are decoded from the segment, which are then written in the decoded CSV data file (\Lines 12-14).


\input{chapters/3-Algorithms/pseudo/09-CA/CA-M-D}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\subsection{Example}
\label{algo:ca:example}


\exampleIntro{\ref{example:ca:1}}


This example involves encoding 12 samples, so no window can reach the maximum size (256). Therefore, the current column entry is added to the current window, $\window$, as long as the incoming point (\incoming) lies within the cone determined by the two rays departing from the archived point (\archived).


In the first iteration, the condition in \Line 5 is satisfied, so \archived is made equal to \incomingP{1}, and the current sample is encoded via the auxiliary routine \CAWinStart, using $\logWinSize = \logWinSizeOpt{256}=8$ bits for encoding a 1, and \tobitexp for encoding its value, also 1. In the second iteration, $\window$ is empty, so the condition in \Line 7 is satisfied. Therefore, the snapshot point (\snapshot) is made equal to \incomingP{2}, the current sample (1) is added to $\window$, and two rays, \smin and \smax, are defined. Figure~\ref{example:ca:1} shows both saved points, \archived and \snapshot, as well as both rays, \smin and \smax, after the second iteration is completed.


\vspace{+5pt}
\exampleStep{ca}{1}{\label{example:ca:1}}{1}


In the third iteration, another sample value equal to 1 is processed. In Figure~\ref{example:ca:2}, point \incomingP{3}, as well as segment \EseEP{3}, defined in \Line 11, is shown.


\vspace{+5pt}
\exampleStep{ca}{2}{\label{example:ca:2}}{2}


\clearpage


Since \incomingP{3} lies within the cone determined by the two rays departing from \archived, the condition in \Line 12 evaluates to false. Therefore, \snapshot is made equal to \incomingP{3}, the current sample is added to $\window$, and \smin and \smax are updated (\Lines 17-20). Figure~\ref{example:ca:3} shows the information after the third iteration is completed.


\vspace{+5pt}
\exampleStep{ca}{3}{\label{example:ca:3}}{3}


The following two iterations are similar to the last one. In each iteration, the sample values are added to the window, and both rays, \smin and \smax, are updated, reducing the slope of the cone. Figure~\ref{example:ca:4} shows the information after the 5th iteration is completed.


\vspace{+5pt}
\exampleStep{ca}{4}{\label{example:ca:4}}{4}


\clearpage


In the 6th iteration, sample value 2 is processed. In Figure~\ref{example:ca:5}, point \incomingP{6} and segment \EseEP{6} are shown.


\exampleStep{ca}{5}{\label{example:ca:5}}{5}


\incomingP{6} lies within the cone, so the condition in \Line 12 evaluates to false. Therefore, \snapshot is made equal to \incomingP{6}, and the current sample is added to $\window$. In this case, \smin is updated, while \smax remains unchanged. Figure~\ref{example:ca:6} shows the information after the 6th iteration is completed.


\vspace{+5pt}
\exampleStep{ca}{6}{\label{example:ca:6}}{6}


\clearpage

In the 7th iteration, sample value 3 is processed. In Figure~\ref{example:ca:7}, point \incomingP{7} and segment \EseEP{7} are shown.


\exampleStep{ca}{7}{\label{example:ca:7}}{7}


For the first time, the incoming point, \incomingP{7}, lies outside of the cone, so \EseEP{7} has a greater slope than \smax, and the condition in \Line 12 becomes true. Therefore, auxiliary routine \CAWinEnd is invoked, which uses $\logWinSize = 8$ bits for encoding the size of $\window$ (5), and \tobitexp for encoding its last sample (2). Next, $\window$ is emptied, \archived is made equal to \incomingP{7}, and the current sample is encoded via the routine \CAWinStart, using $\logWinSize =8$ bits for encoding a 1, and \tobitexp for encoding its value (3). In the following iteration, $\window$ is empty, so the condition in \Line 7 is satisfied. Therefore, \snapshot is made equal to \incomingP{8}, the current sample (3) is added to $\window$, and \smin and \smax are defined once more. Figure~\ref{example:ca:8} shows the information after the 8th iteration is completed.


\vspace{+5pt}
\exampleStep{ca}{8}{\label{example:ca:8}}{8}


\clearpage


In Figure~\ref{example:ca:9} we present the information after the coding routine has finished. After the last iteration of the loop is executed, $\window$ is not empty, so routine \CAWinEnd is invoked in \Line 25. Besides showing the encoded points and their associated line segments, in Figure~\ref{example:ca:9} we also display the values of the decoded samples, which are the values that the decoding routine, shown in Figure~\ref{pseudoDecoderCA}, writes to the decoded CSV data file. 
% We point out that, since the algorithm must support the scenario in which more than one sample exists for a single timestamp, the archived point must be encoded separately from the rest of the window. Otherwise, the decoding routine may consider that the archived value was the last point of the most recently encoded window.


\vspace{+5pt}
\exampleStep{ca}{9}{\label{example:ca:9}}{9}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\vspace{-10pt}
\subsection{Non-Masking (\NOmaskalgo)\ Variant}
\label{algo:ca:nmvariant}


The coding and decoding routines for variant \NOmaskalgo of algorithm CA are similar to their variant \maskalgo counterparts, the difference being that the former routines are able to handle both sample values and gaps. Recall that in the coding routine for variant \maskalgo, a window is encoded when the incoming point lies outside of the cone determined by the two rays departing from point \archived (\Line 12 in Figure~\ref{pseudoCoderCAM}). The coding routine for variant \NOmaskalgo must also encode a window if the incoming column entry is character \noData\ (gap in the data) and the other entries in the window are sample values, or vice versa. We point out that, in the first scenario, it doesn't make sense defining point \archived, so \Line 15 is not executed in this case. For the same reason, \Line 6 should not be executed if the first column entry is character \noData. Auxiliary routine \CAWinEnd uses the same number of bits for encoding a window that consists of gaps and for encoding a window that consists of sample points, i.e. $\logWinSize+\totbit$, where $\logWinSize$ bits are used for encoding its size, and $\totbit$ bits, \wheretotbit, are used for encoding the special integer \nodata. 

