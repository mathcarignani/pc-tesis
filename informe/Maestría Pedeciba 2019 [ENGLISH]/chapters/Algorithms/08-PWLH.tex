

\section{Algorithms PWLH and PWLHInt}
\label{algo:pwlh}


Algorithm PWLH \cite{coder:pwlh}, also known as PieceWise Linear Histogram, is a Linear model algorithm that supports lossless and near-lossless compression. It has a window size parameter ($w$) that establishes a maximum block size in which the data are separately processed and encoded. For PWLH we define both variants, \maskalgo\ and \NOmaskalgo. Algorithm PWLHInt was implemented by introducing minor design changes to algorithm PWLH. Every comment in the current section pertains both algorithms, except for the specific differences that are pointed out in Subsection~\ref{algo:pwhl:int}.


Since PWLH is a Linear model algorithm, from Section~\ref{algo:decolinear} we recall that its encoding process involves encoding a sequence of line segments. In Figure~\ref{pseudoCoderPWLHM} we show the coding routine for variant \maskalgo. It consists of a loop that iterates over all column entries, which are always integer values (the gaps are encoded separately). The algorithm maintains a window of consecutive points, $\window$, which is initially empty (line 1). In each iteration, the addition of a new incoming point, \point, to the window is considered (lines 3-10). The y-coordinate of the point is equal to the value of the column entry, while its x-coordinate is equal to the timestamp for said entry (lines 3-4). In line 5, a convex hull of the set that consists of every point in $\window$, plus \point, is obtained. If \point\ makes the convex hull violate the error threshold constraint, or the window size is greater than $\win$, then the window is encoded, and a new empty window is created (lines 8-9). In any case, \point\ is added to $\window$ (line 11), and is eventually encoded. In particular, if the loop ends and $\window$ is not empty, it is encoded, whether it consists of a single (lines 14-15) or multiple values (line 17).


\clearpage


\input{chapters/Algorithms/pseudo/08-PWLH/PWLH-M-C}


The routine called for encoding a window (lines 8 and 17), EncodeWindow, is shown in Figure~\ref{pwlhWindowM}. The points in a window are modeled by a line segment that minimizes the mean square error for those points (line 1). For the operations in the two-dimensional Euclidean space, which involve calculating said segment, and computing the convex hull of the data points by applying Graham's Scan algorithm~\cite{GrahamAlgo}, we reuse part of the source code from the framework cited in~\cite{AnEva2013}. Encoding a window involves encoding its size (line 3), together with the y-coordinates of both endpoints of the segment (lines 4-5). The window size is encoded using $\logWinSize$ bits, while each of the y-coordinates is encoded as a float, i.e. using 4 bytes, since this is the precision adopted in the method we reuse for calculating the segment. We point out that the values of the x-coordinates are encoded with the timestamp column (line 9 in Figure~\ref{pseudoCodeCommon}), so this routine must not encode them again. 


\input{chapters/Algorithms/pseudo/08-PWLH/PWLH-Win-M-C}


\clearpage


The decoding routine for variant \maskalgo\ is shown in Figure~\ref{pseudoDecoderPWLHM}. It consists of a loop that repeats until every entry in the column has been decoded, which occurs when condition in line 2 becomes false. Recall that the coding algorithm encodes the timestamp column (line 5 in Figure~\ref{pseudoCodeCommon}), so this information is known by the decoding routine (input \tscol). Each iteration of the loop starts with the decoding of the window size (line 3). If the window size is greater than 1, then the points in the window are modeled by a line segment, which means it was encoded via the EncodeWindow routine (recall Figure~\ref{pwlhWindowM}). In this case, the decoding routine decodes a pair of floats corresponding to the y-coordinates of the segment's endpoints (lines 5-6), obtains the timestamps corresponding to their x-coordinates (line 7), and calls the \decodeSegment\ routine with those inputs (line 8). As we recall from Figure~\ref{pseudoDecoLinear}, the \decodeSegment\ routine returns a list consisting of the sample values that are decoded from the segment, which are then written in the decoded csv data file (lines 9-11). On the other hand, if the window size is equal to 1, a fixed number of bits is read, from which a value is decoded and written to the decoded file (lines 13-14).


\input{chapters/Algorithms/pseudo/08-PWLH/PWLH-M-D}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\subsection{Example}
\label{algo:pwlh:example}


Next we present an example of the encoding of 12 samples illustrated in Figure~\ref{example:pca:1}. Since PWLH is a Linear model algorithm, the specific timestamp values are required in the encoding routine (recall that the timestamps column is an input in Figure~\ref{pseudoCoderPWLHM}). We consider that the distance between any pair of adjacent timestamps is equal to 60. In this example we use algorithm PWLH with an error threshold parameter ($\maxerror$) equal to 1, and a maximum window size ($\win$) equal to 256.


\clearpage


Since there are only 12 samples to encode, no window in this example can reach the maximum size (256). Therefore, a window is only encoded when the convex hull violates the error threshold constraint in line 6 of the coding routine. In the first iteration, the window is empty, so the algorithm just adds the first sample point. Figure~\ref{example:pwlh:1} shows this step in the graph. Observe that, besides the sample values, the convex hull for the current window is also shown.


\exampleStep{pwlh}{1}{\label{example:pwlh:1}}{Algorithm PWLH example. Step 1.}


\newcommand{\widthh}{\textit{width}}
The convex hull that includes the second sample point consists of a single edge, and the maximum distance from either point to the edge is zero, i.e. $\widthh = 0 \leq 2*\maxerror = 2$, so the condition in line 6 is satisfied, and the second sample point is added to the window. This step is shown in Figure~\ref{example:pwlh:2}.


\exampleStep{pwlh}{2}{\label{example:pwlh:2}}{Algorithm PWLH example. Step 2.}


\clearpage


The sample values processed in the following three iterations are also equal to 1. The convex hull that includes those points still consists of a single edge, so \widthh\ doesn't change and the threshold constrain is not violated in any case. Therefore, the three sample points are added to the window. This step is shown in Figure~\ref{example:pwlh:3}.


\exampleStep{pwlh}{3}{\label{example:pwlh:3}}{Algorithm PWLH example. Step 3.}


In the next iteration, sample value 2 is considered. The updated convex hull, which now consists of three edges, is shown in Figure~\ref{example:pwlh:4}. In this case, the maximum distance between its upper edge and any of its points is approximately $0.8$. Therefore, $\widthh \approx 0.8 \leq 2$, so the condition in line 6 is still satisfied, and the sample point is added to the window.


\exampleStep{pwlh}{4}{\label{example:pwlh:4}}{Algorithm PWLH example. Step 4.}


\clearpage


The following three iterations are similar to the previous one. In every case, the convex hull is updated, and, even though the maximum distance between its upper edge and any of its points increases, it is never larger than 2, so the threshold constraint is never violated and the three sample points are added to the window. These steps are shown in figures~\ref{example:pwlh:5}, \ref{example:pwlh:6} and \ref{example:pwlh:7}. 


\exampleStep{pwlh}{5}{\label{example:pwlh:5}}{Algorithm PWLH example. Step 5.}
\exampleStep{pwlh}{6}{\label{example:pwlh:6}}{Algorithm PWLH example. Step 6.}


\clearpage


\exampleStep{pwlh}{7}{\label{example:pwlh:7}}{Algorithm PWLH example. Step 7.}


Eventually, in the 10th iteration, sample value 2 is considered. The updated convex hull, which is shown in Figure~\ref{example:pwlh:8}, violates the error threshold constraint in line 6 for the first time. Observe that, for every one of the four edges in the convex hull, there exists a point in the hull such that its distance to the edge is larger than 2. 


\exampleStep{pwlh}{8}{\label{example:pwlh:8}}{Algorithm PWLH example. Step 8.}


\clearpage


Since the condition in line 7 becomes true, the window is encoded via the EncodeWindow routine (line 8), and the point for sample value 2 is added to a new empty window (lines 9 and 11). The EncodeWindow routine (recall Figure~\ref{pwlhWindowM}) models the points in the window through the line segment that minimizes the mean square error for those points. This segment and its two endpoints are shown in Figure~\ref{example:pwlh:9}. Encoding the window requires $\logWinSize = \logWinSizeOpt{256}=8$ bits for encoding its size (i.e. 9), and 32 bits for encoding each of the float values corresponding to the y-coordinates of the segment's endpoints.


\exampleStep{pwlh}{9}{\label{example:pwlh:9}}{Algorithm PWLH example. Step 9.}


In the last two iterations of the coding routine, which correspond to the last two samples, the threshold constraint is not violated. Therefore, after executing the last iteration, $\window$ includes three points, so it is once again encoded via the EncodeWindow routine (line 17). The associated segment and its two endpoints are shown in Figure~\ref{example:pwlh:10}. In this figure we also display the values of the decoded samples, which are the values that the decoding routine, shown in Figure~\ref{pseudoDecoderPWLHM}, would write to the decoded csv data file. 
% that consists of the union of decoded samples obtained by calling the DecodeSegment routine for each encoded segment.


\exampleStep{pwlh}{10}{\label{example:pwlh:10}}{Algorithm PWLH example. Step 10.}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\clearpage
\subsection{Differences between algorithms PWLH and PWLHInt}
\label{algo:pwhl:int}


Recall, from Section~\ref{datasets:over}, that the signals we are interested in compressing consist entirely of integer data samples. However, algorithm PWLH encodes the y-coordinates of a line segment's endpoints as floats, using 4 bytes (recall lines 4-5 in the EncodeWindow routine, shown in Figure~\ref{pwlhWindowM}). Since those y-coordinates correspond to the data samples domain, we realized that the compression performance of algorithm PWLH could be improved if they were instead encoded as bounded integers, using a fixed number of bits that depends on the data type and the dataset, which is the scheme adopted by most of the algorithms implemented in the project. That is precisely the idea behind the design of algorithm PWLHInt.


Algorithm PWLHInt was implemented by applying three changes to algorithm PWLH. First, we made the adjustment mentioned above, and changed lines 4-5 in the EncodeWindow routine, so that both y-coordinates are rounded to the nearest integer, then encoded using a (column-specific) fixed number of bits. Lines 5-6 were modified accordingly in the decoding routine (this is the only change required in the decoding routine). Secondly, we had to add a new constraint to the condition in line 7 of the coding routine, shown in Figure~\ref{pseudoCoderPWLHM}, to make sure that the (rounded) y-coordinates of both endpoints of the approximation segment belong to the range defined for the data type being encoded. Otherwise, the fixed number of bits used for encoding the coordinates may not be enough. Lastly, rounding a coordinate value to the nearest integer, before encoding it, could represent a deviation of as much as 0.5 from its original value. Therefore, the coding routine of algorithm PWLHInt must operate with a lower maximum error threshold, i.e. $\maxerror' = \maxerror - 0.5$, to make sure that error threshold constraint holds, and the per-sample error between the decoded and the original signals is less than or equal to \maxerror.


In Section~\ref{secX:codersmask}, in which we evaluate the coding algorithms implemented in the project, the experimental results suggest that the compression performance of algorithm PWLHInt is superior to that of algorithm PWLH. For instance, compare the plots in Figure~\ref{fig:algo-per-1}, and the data in Table~\ref{experiments:minmaxone}.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\subsection{Non-masking (\NOmaskalgo)\ variant}
\label{algo:pwhl:nmvariant}


The coding and decoding routines for variant \NOmaskalgo\ of algorithms PWLH and PWLHInt are similar to their variant \maskalgo\ counterparts, the difference being that the former routines are able to handle both sample values and gaps. In the coding routine for variant \NOmaskalgo, a window may consist either of points or of gaps, but it cannot include both. Therefore, a new constraint is added to the condition in line 7 of the coding routine, shown in Figure~\ref{pseudoCoderPWLHM}, so that a window is also encoded if the newest entry is character \noData\ (gap in the data) and the other entries in the window are points, or vice versa. To encode a window that consists of gaps, algorithm PWLH uses $\logWinSize$ bits for encoding its size, and 4 bytes for encoding the special float \nodatafloat, while Algorithm PWLHInt also uses $\logWinSize$ bits for encoding its size, but it uses $\colTotBits$ bits for encoding the special integer \nodata.

