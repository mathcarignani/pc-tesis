
\section{Encoding scheme for Linear model algorithms}
\label{algo:decolinear}


In the following four sections we present the Linear model algorithms implemented and evaluated in the project. As we recall from Section~\ref{algo:overview}, these type of algorithms approximate signals using linear, non-constant functions, so their implementations always require operating in the two-dimensional Euclidean space. Even though the encoding scheme varies between algorithms, it always involves encoding a sequence of line segments. Each line segment is encoded through its two endpoints, with their x-coordinates and y-coordinates corresponding to timestamps and sample values, respectively.


In Figure~\ref{pseudoDecoLinear} we present the DecodeSegment routine, which is called by the decoding routine of every one of the Linear model algorithms. Its inputs are the timestamps column (recall that this column is encoded in line 5 of the routine shown in Figure~\ref{pseudoCodeCommon}), and a pair of timestamps and sample values, from which the coordinates of the encoded line segment's endpoints are obtained (line 1). The output is a list consisting of the sample values that are decoded from said segment, which the decoding routine must then write to the decoded csv data file.


\input{chapters/Algorithms/pseudo/07-DecoLinear/DecoLinear}


We point out that the timestamps in the column are non-negative bounded integers (bounded in the sense that their range is known a priori by the coding routine, so they are always encoded using a fixed number of bits). For most algorithms, both the x-coordinates and the y-coordinates of the endpoints are encoded as bounded integers, the exceptions being algorithm PWLH, which encodes the y-coordinates as floats, and algorithm SF, which encodes the coordinates of both axes as floats.


\clearpage


Next, we present an example that details how the \decodeSegment\ routine works. The inputs are represented in Figure~\ref{example:linear}: the coordinates of the encoded segment's endpoints are $(t_5,1)$ \color{white}and\color{black}

\vspace{-21pt}
\begin{table}[h]
\begin{minipage}{0.45\textwidth}
\setstretch{1.1}
% \vspace{-35pt}
and $(t_9,3.5)$, while the timestamps column is equal to $[t_1,...,t_N]$, where $N \geq 9$. The segment defined in line 1 of the routine is colored red. After creating the empty list of decoded samples (line 2), a loop iterates over every timestamp $t_i$, $t_5 \leq t_i \leq t_9$, in the column, it decodes the corresponding sample value $s_i$ (line 4), and adds it to the list (line 5). Given timestamp $t_i$, sample value $s_i$ is obtained by taking the equation of the segment and substituting the x-coordinate by $t_i$, then rounding the result to the nearest integer. In Figure~\ref{example:linear}, the decoded sample values, $s_i$, $5 \leq i \leq 9$, are colored in orange. They are equal to $[1, 2, 2, 3, 4]$, which is the list output by the \decodeSegment\ routine in this example.
\end{minipage}
\hspace{0.02\textwidth}
\begin{minipage}{0.49\textwidth}
\examplelinear
\end{minipage}
\end{table}

