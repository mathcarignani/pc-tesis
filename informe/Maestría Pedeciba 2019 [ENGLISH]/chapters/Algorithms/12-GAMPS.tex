
\clearpage

\section{Algorithm GAMPS}
\label{algo:gamps}

Algorithm GAMPS \cite{coder:gamps}, also known as Grouping and AMPlitude Scaling, is a Correlation model algorithm that supports lossless and near-lossless compression. It has a window size parameter ($w$) that establishes the maximum block size in which the data are separately processed and encoded. For GAMPS we define both variants, \maskalgo\ and \NOmaskalgo.


In Figure~\ref{pseudoCoderGAMPS} we show the coding routine for variant \maskalgo. Notice that the first input consists of all the columns in the csv data file, while in the routines for the Constant and Linear model algorithms, presented in previous sections, it is a single column. This is because those kind of algorithms only exploit the temporal correlation in the data, thus they encode each data column independently. However, Correlation models, such as GAMPS, also exploit the spatial correlation, so the data columns are encoded simultaneously. Another difference with the previously presented algorithms, is that GAMPS is an offline encoder, since the whole dataset is available when the coding routine begins. 


\input{chapters/Algorithms/pseudo/12-GAMPS/GAMPS-M-C}


The initial step in the coding routine, which gives the first part of its name to the algorithm, consists of grouping the data columns into disjoint subsets of spatially correlated columns (line~1). In each subset, a single base column is defined, and the rest of columns are considered ratio columns. A facility location problem, whose goal is to find a grouping that reduces the number of bits required for encoding the columns, is resolved \cite{coder:gamps}. Its inputs are the set of columns, \columns, and the maximum error threshold, \maxerror, and the output is the grouping and the maximum error threshold parameters, \epsilonB\ and \epsilonR, for the base and ratio columns, respectively. To solve the facility location problem we reuse the source code from the framework cited in \cite{AnEva2013}. We point out that we narrow the universe of solutions by only allowing columns corresponding to signals of the same data type to be grouped together. We find out that this not only reduces the size of the facility location problem, which is computationally expensive to solve, but in our case it also lead to better compression results. 


The next step in the coding routine consists of encoding the number of subsets (line 2). Afterwards, the routine iterates through each subset of columns (lines 3-12), and, in each iteration, all the data columns in the subset are encoded. In line 6, the index of the base column, and the number of ratio columns and their respective indexes are encoded. This information is used by the decoding routine to recreate each subset. In line 7, the base column is encoded by invoking the coding routine for algorithm APCA, shown in Figure~\ref{pseudoCoderAPCAM}, with an error threshold equal to \epsilonB. Finally, there is a loop in lines 8-11, in which each of the ratio columns is transformed, then encoded by invoking the APCA coding routine\footnote{Since the transformed ratio columns may include of non-integer values, in this case the EncodeWindow routine for algorithm APCA, shown in Figure~\ref{apcaWindowM}, must encode the \midrange\ as a float, i.e. using 4 bytes.}, with an error threshold equal to \epsilonR.


Notice that the transformation applied to a ratio column, in line 9, consists in dividing each sample by the base column sample for the same timestamp. The original ratio signals may be rough, but, since there is a high degree of spatial correlation among base and ratio signals in a group, the transformed ratio signals are expected to be slowly varying. As we recall from Section~\ref{algo:apca}, algorithm APCA achieves better compression performances on slowly varying signals rather than rough signals. Therefore, the key idea behind algorithm GAMPS is that, under certain circumstances, it can be more convenient to exploit the spatial correlation between the signals and encode the slowly varying transformed signals, rather than independently encode the original rough signals.


The decoding routine is symmetric to the coding routine. To recreate each subset, the information encoded in lines 2 and 6 of the coding routine is decoded. For decoding the data columns in each subset, first, the base column is decoded by invoking the decoding routine for algorithm APCA. Then, each of the transformed ratio columns is decoded, also by invoking the APCA decoding routine, and the transformation applied in line 9 is reverted, by multiplying the decoded base column by the decoded transformed ratio column.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\clearpage


\subsection{Example}
\label{algo:gamps:example}


Next we present an example of the encoding of three signals with 12 samples each, illustrated in Figure~\ref{example:gamps:1}. Notice that, since the specific timestamp values are irrelevant for algorithm APCA, they are also irrelevant for this algorithm. In this example we use algorithm GAMPS with an error threshold parameter ($\maxerror$) equal to 0, and a maximum window size ($\win$) equal to 256.


\exampleStep{gamps}{1}{\label{example:gamps:1}}{Algorithm GAMPS example. Step 0.}


There is a high degree of spatial correlation among the three signals, with the sample values matching for 10 of the 12 timestamps. Therefore, in line 1, a single subset including the three columns with the samples of each signal is created. The first column is defined as the base column, making the remaining two, ratio columns. Since \maxerror\ is equal to 0, both \epsilonB\ and \epsilonR, must also be 0. In line 2, the number of subsets (i.e. 1) is encoded using $\gampsSizeAux{|\columns|}=\gampsSizeAux{3}=2$ bits. Since there is a single subset, there is a single iteration. In line 6, the information used by the decoding routine to recreate the subset is encoded, using $\gampsSizeAux{|\columns|}=2$ bits for encoding each of the following values: the index of the base column (i.e. 0), the number of ratio columns (i.e. 2), and the index of each ratio column (i.e. 1 and 2). 


Next, in line 7, the base column is encoded by calling the coding routine for algorithm APCA. Since \epsilonB\ is equal to 0, the encoded samples match the original samples. The loop in lines 8 through 11 repeats for each of the two ratio columns. In both cases, the ratio column is first transformed (line 9), then encoded by calling the APCA coding routine (line 10). Since parameter \epsilonR\ is equal to 0, the encoded samples match the transformed samples, which are equal to $[1, 1, 1, 1, 1, 4/3, 4/3, 1, 1, 1, 1, 1]$ and $[1, 1, 1, 1, 1, 2/3, 2/3, 1, 1, 1, 1, 1]$, respectively, for each transformed ratio column. In Figure~\ref{example:gamps:2}, the encoded samples of the three signals are shown. 


We recall that the coding routine for algorithm APCA always uses the same amount of bits for encoding a window. If the three signals were independently encoded with APCA, the first one would require encoding 5 windows, and the second and third signals would require encoding 7 windows each. However, in this case, only 3 windows are required for encoding each of the transformed ratio signals with algorithm APCA. This is expected because, since there is a high degree of spatial correlation among the signals, the transformed ratio signals are slowly varying, compared to the original ratio signals, which are more rough.


\clearpage


\exampleStep{gamps}{2}{\label{example:gamps:2}}{Algorithm GAMPS example. Step 1.}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\subsection{Non-masking (\NOmaskalgo)\ variant}
\label{algo:gamps:nmvariant}


The coding and decoding routines for variant \NOmaskalgo\ of algorithm GAMPS are quite similar to their variant \maskalgo\ counterparts, the difference being that the former routines are able to handle both sample values and gaps. The coding routine for variant \maskalgo\ invokes the coding routine for variant \maskalgo\ of algorithm APCA (lines 7 and 10 in Figure~\ref{pseudoCoderGAMPS}), which can only handle sample values, since the position of the gaps is already encoded (recall line 7 in Figure~\ref{pseudoCodeCommon}). However, the coding routine for variant \NOmaskalgo\ must instead invoke the coding routine for variant \NOmaskalgo\ of algorithm APCA, which is able to handle both sample values and gaps.

